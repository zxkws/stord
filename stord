#!/usr/bin/env bash
set -Eeuo pipefail

STORD_VERSION="0.2.6"

PROG_NAME_DEFAULT="stord"
PROG_NAME="${PROG_NAME:-$PROG_NAME_DEFAULT}"

STORD_RAW_URL_DEFAULT="https://raw.githubusercontent.com/zxkws/stord/main/stord"
STORD_RAW_URL="${STORD_RAW_URL:-${STORD_URL:-$STORD_RAW_URL_DEFAULT}}"

# When running as `curl ... | bash`, stdin is not a TTY. Read input from /dev/tty if available.
# In non-TTY contexts (CI), /dev/tty may not be configured, so this must be best-effort.
STORD_INPUT_FD=0
if [[ ! -t 0 && -t 1 && -r /dev/tty ]]; then
  # shellcheck disable=SC2094
  if exec 3</dev/tty; then
    STORD_INPUT_FD=3
  fi
fi

is_root() { [[ "${EUID:-$(id -u)}" -eq 0 ]]; }

require_root() {
  if ! is_root; then
    die "需要以 root 用户运行（请使用 sudo 或切换到 root）"
  fi
}

default_home() {
  echo "/opt/${PROG_NAME}"
}

STORD_HOME="${STORD_HOME:-$(default_home)}"
STORD_SERVICES_DIR="${STORD_SERVICES_DIR:-${STORD_HOME}/services}"
STORD_BACKUPS_DIR="${STORD_BACKUPS_DIR:-${STORD_HOME}/backups}"
STORD_STATE_DIR="${STORD_STATE_DIR:-${STORD_HOME}/state}"
STORD_LOG_DIR="${STORD_LOG_DIR:-${STORD_HOME}/logs}"
STORD_RECORD_FILE="${STORD_RECORD_FILE:-${STORD_STATE_DIR}/install-records}"

umask 077

STORD_ASSUME_YES="${STORD_ASSUME_YES:-0}"                 # --yes
STORD_NON_INTERACTIVE="${STORD_NON_INTERACTIVE:-0}"       # --non-interactive (use defaults, but don't auto-confirm)
STORD_QUIET="${STORD_QUIET:-0}"                           # --quiet
STORD_DEBUG="${STORD_DEBUG:-0}"                           # --debug

on_error() {
  local code=$?
  local line="${BASH_LINENO[0]:-?}"
  local cmd="${BASH_COMMAND:-?}"
  printf "错误：第 %s 行失败：%s\n" "${line}" "${cmd}" >&2
  exit "${code}"
}
trap on_error ERR

say() {
  [[ "${STORD_QUIET}" == "1" ]] && return 0
  printf "%s\n" "$*"
}
warn() { printf "警告：%s\n" "$*" >&2; }
die() { printf "错误：%s\n" "$*" >&2; exit 1; }

if [[ "${STORD_DEBUG}" == "1" ]]; then
  set -x
fi

have() { command -v "$1" >/dev/null 2>&1; }

require() {
  local cmd="$1"
  have "${cmd}" || die "缺少依赖：${cmd}"
}

os_release_value() {
  local key="$1"
  local val=""
  if [[ -r /etc/os-release ]]; then
    val="$(grep -E "^${key}=" /etc/os-release | head -n 1 | cut -d= -f2- | tr -d '"')"
  fi
  printf "%s" "${val}"
}

docker_install_supported() {
  local id like
  id="$(os_release_value ID)"
  like="$(os_release_value ID_LIKE)"
  case " ${id} ${like} " in
    *" ubuntu "*|*" debian "*|*" raspbian "*|*" fedora "*|*" rhel "*|*" centos "*|*" rocky "*|*" almalinux "*|*" ol "*|*" amzn "*|*" sles "*|*" opensuse "*|*" suse "*)
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

docker_proxy_env() {
  local http_proxy_val="${STORD_HTTP_PROXY:-${http_proxy:-${HTTP_PROXY:-}}}"
  local https_proxy_val="${STORD_HTTPS_PROXY:-${https_proxy:-${HTTPS_PROXY:-}}}"
  local no_proxy_val="${STORD_NO_PROXY:-${no_proxy:-${NO_PROXY:-}}}"
  local -a envs=()
  if [[ -n "${http_proxy_val}" ]]; then
    envs+=("http_proxy=${http_proxy_val}" "HTTP_PROXY=${http_proxy_val}")
  fi
  if [[ -n "${https_proxy_val}" ]]; then
    envs+=("https_proxy=${https_proxy_val}" "HTTPS_PROXY=${https_proxy_val}")
  fi
  if [[ -n "${no_proxy_val}" ]]; then
    envs+=("no_proxy=${no_proxy_val}" "NO_PROXY=${no_proxy_val}")
  fi
  printf "%s\n" "${envs[@]}"
}

ver_cmp() {
  # Compare two dotted versions (e.g. 0.2.10 vs 0.2.2).
  # Prints -1, 0, or 1.
  local a="$1" b="$2"
  local -a av bv
  local IFS=.
  read -r -a av <<<"${a}"
  read -r -a bv <<<"${b}"
  local i max n1 n2
  max="${#av[@]}"
  (( "${#bv[@]}" > max )) && max="${#bv[@]}"
  for ((i=0; i<max; i++)); do
    n1="${av[i]:-0}"
    n2="${bv[i]:-0}"
    [[ "${n1}" =~ ^[0-9]+$ ]] || n1=0
    [[ "${n2}" =~ ^[0-9]+$ ]] || n2=0
    if (( n1 < n2 )); then echo -1; return 0; fi
    if (( n1 > n2 )); then echo 1; return 0; fi
  done
  echo 0
}

remote_version() {
  require curl
  # Pull only what we need: grep/sed on the downloaded script text.
  # If the format changes, this simply returns empty and skips update prompt.
  curl -fsSL "${STORD_RAW_URL}" 2>/dev/null | sed -n 's/^STORD_VERSION="\(.*\)".*/\1/p' | head -n 1 || true
}

check_update() {
  local rv
  rv="$(remote_version || true)"
  if [[ -z "${rv}" ]]; then
    say "更新检查：无法获取远端版本。"
    return 0
  fi
  say "本地：${STORD_VERSION}"
  say "远端：${rv}"
  if [[ "$(ver_cmp "${STORD_VERSION}" "${rv}")" -lt 0 ]]; then
    say "发现新版本。"
    return 0
  fi
  say "已是最新。"
  return 0
}

confirm() {
  local prompt="${1:-继续？}"
  local ans
  while true; do
    if [[ "${STORD_ASSUME_YES}" == "1" ]]; then
      return 0
    fi
    if [[ "${STORD_NON_INTERACTIVE}" == "1" ]]; then
      return 1
    fi
    read -r -u "${STORD_INPUT_FD}" -p "${prompt} [Y/n] " ans || true
    ans="${ans:-Y}"
    case "${ans,,}" in
      y|yes|是|好|1|true) return 0 ;;
      n|no|否|不|0|false) return 1 ;;
      *) say "请输入 y 或 n。" ;;
    esac
  done
}

prompt() {
  local label="$1"
  local def="${2:-}"
  local out
  if [[ "${STORD_NON_INTERACTIVE}" == "1" ]]; then
    if [[ -n "${def}" ]]; then
      printf "%s" "${def}"
      return 0
    fi
    die "非交互模式需要默认值：${label}"
  fi
  if [[ -n "${def}" ]]; then
    read -r -u "${STORD_INPUT_FD}" -p "${label} [${def}]: " out || true
    out="${out:-$def}"
  else
    read -r -u "${STORD_INPUT_FD}" -p "${label}: " out || true
  fi
  printf "%s" "${out}"
}

prompt_secret() {
  local label="$1"
  local def_hint="${2:-<random>}"
  local out
  if [[ "${STORD_NON_INTERACTIVE}" == "1" ]]; then
    printf "%s" ""
    return 0
  fi
  read -r -s -u "${STORD_INPUT_FD}" -p "${label} [${def_hint}]: " out || true
  printf "\n" >&2
  printf "%s" "${out}"
}

random_hex() {
  local n="${1:-16}"
  if have openssl; then
    openssl rand -hex "${n}" 2>/dev/null | tr -d '\n'
    return 0
  fi
  # fallback
  head -c 1024 /dev/urandom | LC_ALL=C tr -dc 'a-f0-9' | head -c $((n * 2))
}

maybe_offer_update() {
  # Only in interactive menu, and only once per run.
  [[ "${STORD_UPDATE_CHECKED:-0}" == "1" ]] && return 0
  export STORD_UPDATE_CHECKED=1
  [[ "${STORD_NON_INTERACTIVE}" == "1" ]] && return 0
  [[ "${STORD_QUIET}" == "1" ]] && return 0
  [[ "${STORD_NO_UPDATE_CHECK:-0}" == "1" ]] && return 0

  local rv
  rv="$(remote_version || true)"
  [[ -n "${rv}" ]] || return 0
  if [[ "$(ver_cmp "${STORD_VERSION}" "${rv}")" -lt 0 ]]; then
    say
    say "发现新版本：${STORD_VERSION} -> ${rv}"
    if confirm "现在更新 ${PROG_NAME}？"; then
      (STORD_ASSUME_YES=1 self_update)
      say
    fi
  fi
}

record_init() {
  mkdir -p "$(dirname "${STORD_RECORD_FILE}")"
  touch "${STORD_RECORD_FILE}"
}

record_add() {
  local type="$1" path="$2" desc="${3:-}"
  [[ -n "${path}" ]] || return 0
  record_init
  if ! grep -Fq "^${type}|${path}|" "${STORD_RECORD_FILE}" 2>/dev/null; then
    printf "%s|%s|%s\n" "${type}" "${path}" "${desc}" >> "${STORD_RECORD_FILE}"
  fi
}

record_list() {
  [[ -f "${STORD_RECORD_FILE}" ]] || return 0
  grep -v '^[[:space:]]*$' "${STORD_RECORD_FILE}" || true
}

record_remove_path() {
  local path="$1"
  [[ -f "${STORD_RECORD_FILE}" ]] || return 0
  local tmp
  tmp="$(mktemp)"
  awk -F'|' -v p="${path}" 'NF && $2!=p {print}' "${STORD_RECORD_FILE}" > "${tmp}"
  mv -f "${tmp}" "${STORD_RECORD_FILE}"
}

ensure_dirs() {
  if mkdir -p "${STORD_SERVICES_DIR}" "${STORD_BACKUPS_DIR}" "${STORD_STATE_DIR}" "${STORD_LOG_DIR}" >/dev/null 2>&1; then
    record_add "dir" "${STORD_HOME}" "数据根目录"
    record_add "dir" "${STORD_SERVICES_DIR}" "服务目录"
    record_add "dir" "${STORD_BACKUPS_DIR}" "备份目录"
    record_add "dir" "${STORD_STATE_DIR}" "状态目录"
    record_add "dir" "${STORD_LOG_DIR}" "日志目录"
    return 0
  fi
  die "无法创建目录：${STORD_HOME}"
}

mem_total_mb() {
  if [[ -r /proc/meminfo ]]; then
    awk '/MemTotal/ {print int($2/1024)}' /proc/meminfo
    return 0
  fi
  if have sysctl; then
    local bytes
    bytes="$(sysctl -n hw.memsize 2>/dev/null || true)"
    if [[ "${bytes}" =~ ^[0-9]+$ ]]; then
      echo $((bytes / 1024 / 1024))
      return 0
    fi
  fi
  echo 1024
}

clamp_int() {
  local v="$1" min="$2" max="$3"
  if (( v < min )); then echo "${min}"; return 0; fi
  if (( v > max )); then echo "${max}"; return 0; fi
  echo "${v}"
}

suggest_mariadb_buffer_pool_mb() {
  local m; m="$(mem_total_mb)"
  local v=$((m * 30 / 100))
  clamp_int "${v}" 128 512
}

suggest_mongodb_cache_mb() {
  local m; m="$(mem_total_mb)"
  local v=$((m * 25 / 100))
  clamp_int "${v}" 128 512
}

suggest_redis_maxmem_mb() {
  local m; m="$(mem_total_mb)"
  local v=$((m * 12 / 100))
  clamp_int "${v}" 64 256
}

compose_bin() {
  if have docker && docker compose version >/dev/null 2>&1; then
    echo "docker compose"
    return 0
  fi
  if have docker-compose; then
    echo "docker-compose"
    return 0
  fi
  return 1
}

compose() {
  local service="$1"; shift
  local svc_dir="${STORD_SERVICES_DIR}/${service}"
  local f="${svc_dir}/docker-compose.yml"
  [[ -f "${f}" ]] || die "服务未部署：${service}（缺少 ${f}）"

  local cb
  cb="$(compose_bin)" || die "未找到 docker compose（请安装 Docker + compose 插件）"

  # Ensure `.env` and relative paths resolve against the service directory.
  # shellcheck disable=SC2086
  ${cb} --project-directory "${svc_dir}" -f "${f}" "$@"
}

compose_escape_env() {
  printf "\$\$%s" "$1"
}

mask_value() {
  local v="${1:-}"
  if [[ -z "${v}" ]]; then
    echo ""
    return 0
  fi
  if [[ "${#v}" -le 6 ]]; then
    echo "***"
    return 0
  fi
  echo "${v:0:2}***${v: -2}"
}

load_kv() {
  # load env file key=value lines into stdout "key=value"
  local f="$1"
  [[ -f "${f}" ]] || return 0
  grep -E '^[A-Za-z_][A-Za-z0-9_]*=' "${f}" | sed 's/\r$//'
}

show_env() {
  local service="$1"
  local svc_dir="${STORD_SERVICES_DIR}/${service}"
  local envf="${svc_dir}/.env"
  [[ -f "${envf}" ]] || die "缺少 env 文件：${envf}"

  say "服务：${service}"
  say "配置：${svc_dir}"
  say
  while IFS='=' read -r k v; do
    case "${k}" in
      *PASS*|*PASSWORD*|*SECRET*|*TOKEN*)
        say "${k}=$(mask_value "${v}")"
        ;;
      *)
        say "${k}=${v}"
        ;;
    esac
  done < <(load_kv "${envf}")
}

show_env_all() {
  local any=0 svc
  while IFS= read -r svc; do
    [[ -n "${svc}" ]] || continue
    local envf; envf="$(service_dir "${svc}")/.env"
    [[ -f "${envf}" ]] || continue
    any=1
    say
    show_env "${svc}"
  done < <(list_services)
  if [[ "${any}" == "0" ]]; then
    say "暂无已部署服务。"
  fi
}

ensure_docker() {
  if have docker; then
    return 0
  fi
  say "未检测到 Docker。"
  say "建议安装：Docker Engine + compose 插件。"
  say
  if ! docker_install_supported; then
    local id like
    id="$(os_release_value ID)"
    like="$(os_release_value ID_LIKE)"
    warn "当前发行版不在 get.docker.com 支持范围内。"
    say "ID=${id:-unknown}  ID_LIKE=${like:-unknown}"
    say "请使用发行版/云厂商提供的 Docker 安装方式。"
    return 1
  fi
  if confirm "使用官方脚本（get.docker.com）安装 Docker？"; then
    require curl
    local tmp mirror
    tmp="$(mktemp)"
    mirror="${STORD_DOCKER_MIRROR:-}"
    local -a envs mirror_args
    mapfile -t envs < <(docker_proxy_env)
    if [[ -n "${mirror}" ]]; then
      mirror_args=(--mirror "${mirror}")
      say "使用镜像源：${mirror}"
    fi
    if ! env "${envs[@]}" curl -fsSL https://get.docker.com -o "${tmp}"; then
      warn "下载 Docker 安装脚本失败（可能是网络或镜像问题）。"
      rm -f "${tmp}"
      return 1
    fi
    if ! env "${envs[@]}" sh "${tmp}" "${mirror_args[@]}"; then
      warn "Docker 安装失败（可能是网络/镜像/代理问题）。"
      rm -f "${tmp}"
      return 1
    fi
    rm -f "${tmp}"
    say "Docker 已安装。你可能需要重新登录或执行：sudo usermod -aG docker $USER"
  else
    warn "未安装 Docker，已取消。"
    return 1
  fi
}

ensure_compose() {
  compose_bin >/dev/null 2>&1 || die "未找到 docker compose（请安装 compose 插件或 docker-compose）"
}

pkg_manager() {
  if have apt-get; then echo "apt"; return 0; fi
  if have dnf; then echo "dnf"; return 0; fi
  if have yum; then echo "yum"; return 0; fi
  if have apk; then echo "apk"; return 0; fi
  return 1
}

pkg_install() {
  local pm; pm="$(pkg_manager)" || die "未找到支持的包管理器（apt/yum/dnf/apk）"
  if ! is_root; then
    die "安装系统依赖需要 root 权限"
  fi
  case "${pm}" in
    apt)
      DEBIAN_FRONTEND=noninteractive apt-get update -y
      DEBIAN_FRONTEND=noninteractive apt-get install -y "$@"
      ;;
    dnf) dnf install -y "$@" ;;
    yum) yum install -y "$@" ;;
    apk) apk add --no-cache "$@" ;;
  esac
}

ensure_crontab() {
  if have crontab; then
    return 0
  fi
  warn "未找到 crontab；定时备份需要 cron。"
  if ! confirm "现在安装 cron？"; then
    die "未找到 crontab（请先安装 cron）"
  fi
  local pm; pm="$(pkg_manager)" || die "未找到支持的包管理器（apt/yum/dnf/apk）"
  case "${pm}" in
    apt) pkg_install cron ;;
    dnf|yum) pkg_install cronie ;;
    apk) pkg_install cronie ;;
  esac
  have crontab || die "已安装 cron 但仍找不到 crontab"
  warn "cron 已安装，请确保系统里 cron 服务已启用并运行。"
}

write_file() {
  local path="$1"
  local content="$2"
  mkdir -p "$(dirname "${path}")"
  printf "%s" "${content}" > "${path}"
}

service_dir() {
  echo "${STORD_SERVICES_DIR}/$1"
}

env_get() {
  local svc="$1" key="$2"
  local envf; envf="$(service_dir "${svc}")/.env"
  [[ -f "${envf}" ]] || return 1
  grep -E "^${key}=" "${envf}" | head -n 1 | cut -d= -f2- || true
}

svc_default_port() {
  case "${1:-}" in
    mariadb) echo "3306" ;;
    mongodb) echo "27017" ;;
    redis) echo "6379" ;;
    *) echo "" ;;
  esac
}

svc_host_port() {
  local svc="${1:?需要服务名}"
  local port
  port="$(env_get "${svc}" STORE_PORT || true)"
  port="${port:-$(svc_default_port "${svc}")}"
  [[ -n "${port}" ]] || die "未知服务：${svc}"
  echo "${port}"
}

dsn_host_hint() {
  local svc="${1:?需要服务名}"
  local host
  host="$(env_get "${svc}" STORE_BIND || true)"
  host="${host:-127.0.0.1}"
  if [[ "${host}" == "0.0.0.0" ]]; then
    echo "<server-host>"
  else
    echo "${host}"
  fi
}

container_name() {
  local svc="${1:?需要服务名}"
  echo "${PROG_NAME}-${svc}"
}

warn_if_public_bind() {
  local bind="$1" port="$2" svc="$3"
  if [[ "${bind}" == "0.0.0.0" ]]; then
    warn "${svc} 绑定到 0.0.0.0:${port}（公网可达）。请用防火墙仅放行你的应用服务器 IP。"
  fi
}

is_valid_port() {
  local p="${1:-}"
  [[ "${p}" =~ ^[0-9]+$ ]] || return 1
  (( p >= 1 && p <= 65535 ))
}

port_in_use_proc() {
  local port="${1:?需要端口}"
  is_valid_port "${port}" || return 1
  local ph
  ph="$(printf "%04X" "${port}")"
  # /proc/net/tcp and /proc/net/tcp6 are Linux-only but require no extra tools.
  awk -v ph="${ph}" '
    NR==1 {next}
    {
      split($2, a, ":");
      p=toupper(a[2]);
      st=$4;
      if (p==ph && st=="0A") {found=1; exit}
    }
    END {exit(found?0:1)}
  ' /proc/net/tcp 2>/dev/null && return 0 || true
  awk -v ph="${ph}" '
    NR==1 {next}
    {
      split($2, a, ":");
      p=toupper(a[2]);
      st=$4;
      if (p==ph && st=="0A") {found=1; exit}
    }
    END {exit(found?0:1)}
  ' /proc/net/tcp6 2>/dev/null && return 0 || true
  return 1
}

port_in_use() {
  local port="${1:?需要端口}"
  if [[ -r /proc/net/tcp ]]; then
    port_in_use_proc "${port}"
    return $?
  fi
  if have ss; then
    ss -ltnH 2>/dev/null | awk '{print $4}' | grep -Eq "[:.]${port}\$" && return 0 || true
    return 1
  fi
  if have lsof; then
    lsof -nP -iTCP:"${port}" -sTCP:LISTEN >/dev/null 2>&1 && return 0 || true
    return 1
  fi
  if have netstat; then
    netstat -ltn 2>/dev/null | awk '{print $4}' | grep -Eq "[:.]${port}\$" && return 0 || true
    return 1
  fi
  # Unknown platform / no tools: best-effort says "not in use".
  return 1
}

random_free_port() {
  local min=20000 max=65000 tries=80 p
  for ((i=0; i<tries; i++)); do
    p=$((min + (RANDOM % (max - min + 1))))
    if ! port_in_use "${p}"; then
      echo "${p}"
      return 0
    fi
  done
  for ((p=min; p<=max; p++)); do
    if ! port_in_use "${p}"; then
      echo "${p}"
      return 0
    fi
  done
  die "无法在 ${min}-${max} 范围内找到可用端口"
}

select_port() {
  local svc="${1:?需要服务名}"
  local label="${2:?需要名称}"
  local def="${3:?需要默认端口}"

  if [[ "${STORD_NON_INTERACTIVE}" == "1" ]]; then
    if port_in_use "${def}"; then
      die "${label} 默认端口 ${def} 已被占用；请用交互模式重新选择端口"
    fi
    echo "${def}"
    return 0
  fi

  local port
  if confirm "使用默认端口 ${def}？"; then
    if port_in_use "${def}"; then
      warn "端口 ${def} 已被占用，需选择其他端口。"
    else
      echo "${def}"
      return 0
    fi
  fi

  if confirm "使用随机可用端口？"; then
    port="$(random_free_port)"
    say "已选择随机端口：${port}"
    echo "${port}"
    return 0
  fi

  port="$(prompt "${label} 端口" "")"
  while true; do
    if ! is_valid_port "${port}"; then
      warn "端口无效：${port}（必须是 1-65535）"
      port="$(prompt "${label} 端口" "${def}")"
      continue
    fi
    if ! port_in_use "${port}"; then
      echo "${port}"
      return 0
    fi

    warn "端口 ${port} 已被占用。"
    say "1) 使用随机可用端口"
    say "2) 输入其他端口"
    say "3) 取消"
    local choice
    choice="$(prompt "选择" "1")"
    case "${choice}" in
      1)
        port="$(random_free_port)"
        say "已选择随机端口：${port}"
        echo "${port}"
        return 0
        ;;
      2)
        port="$(prompt "${label} 端口" "")"
        ;;
      3)
        die "已取消"
        ;;
      *)
        say "未知选项。"
        ;;
    esac
  done
}

deploy_mariadb() {
  ensure_dirs
  ensure_docker || return 1
  ensure_compose || return 1

  local svc="mariadb"
  local svc_dir="${STORD_SERVICES_DIR}/${svc}"
  mkdir -p "${svc_dir}/data" "${svc_dir}/conf.d"
  record_add "service" "${svc_dir}" "服务 mariadb"

  local bind default_bind port rootpw db user pass buf_mb
  default_bind="0.0.0.0"
  bind="$(prompt "绑定地址（0.0.0.0 远程可访问，127.0.0.1 仅本机）" "${default_bind}")"
  port="$(select_port "${svc}" "MariaDB" "3306")"
  db="$(prompt "数据库名" "appdb")"
  user="$(prompt "应用用户名" "app")"

  rootpw="$(prompt_secret "Root 密码" "<random>")"
  if [[ -z "${rootpw}" ]]; then rootpw="$(random_hex 16)"; fi
  pass="$(prompt_secret "应用用户密码" "<random>")"
  if [[ -z "${pass}" ]]; then pass="$(random_hex 16)"; fi

  buf_mb="$(prompt "InnoDB 缓冲池（MB）" "$(suggest_mariadb_buffer_pool_mb)")"
  if [[ ! "${buf_mb}" =~ ^[0-9]+$ ]]; then die "缓冲池必须是整数（MB）"; fi

  write_file "${svc_dir}/.env" \
    "MARIADB_ROOT_PASSWORD=${rootpw}
MARIADB_DATABASE=${db}
MARIADB_USER=${user}
MARIADB_PASSWORD=${pass}
TZ=Asia/Seoul
STORE_BIND=${bind}
STORE_PORT=${port}
"

  write_file "${svc_dir}/conf.d/my.cnf" \
"[mysqld]
innodb_buffer_pool_size=${buf_mb}M
innodb_log_file_size=64M
innodb_flush_log_at_trx_commit=2
max_connections=80
thread_cache_size=32
table_open_cache=1024
tmp_table_size=32M
max_heap_table_size=32M
slow_query_log=1
long_query_time=1
log_queries_not_using_indexes=0
skip_name_resolve=ON
default_time_zone='+09:00'
character-set-server=utf8mb4
collation-server=utf8mb4_unicode_ci
"

  write_file "${svc_dir}/docker-compose.yml" \
"services:
  mariadb:
    image: mariadb:10.11
    container_name: ${PROG_NAME}-mariadb
    restart: unless-stopped
    env_file: .env
    ports:
      - \"${bind}:${port}:3306\"
    volumes:
      - ./data:/var/lib/mysql
      - ./conf.d/my.cnf:/etc/mysql/conf.d/my.cnf:ro
    command:
      - --character-set-server=utf8mb4
      - --collation-server=utf8mb4_unicode_ci
      - --skip-name-resolve
    healthcheck:
      test: [\"CMD-SHELL\", \"mysqladmin ping -h 127.0.0.1 -p$(compose_escape_env MARIADB_ROOT_PASSWORD) --silent\"]
      interval: 10s
      timeout: 5s
      retries: 12
"

  say
  say "即将部署 MariaDB："
  say "- 目录：${svc_dir}"
  say "- 绑定：${bind}:${port}"
  say
  warn_if_public_bind "${bind}" "${port}" "mariadb"
  if ! confirm "现在执行 docker compose up -d？"; then
    say "已保存配置。稍后可用：${PROG_NAME} start mariadb"
    return 0
  fi

  compose "${svc}" up -d
  say "MariaDB 已启动。"
  say
  say "连接信息："
  say "- host：${bind}"
  say "- port：${port}"
  say "- db：  ${db}"
  say "- user：${user}"
  say "- pass：${pass}"
  say "- root：${rootpw}"
}

deploy_mongodb() {
  ensure_dirs
  ensure_docker || return 1
  ensure_compose || return 1

  local svc="mongodb"
  local svc_dir="${STORD_SERVICES_DIR}/${svc}"
  mkdir -p "${svc_dir}/data" "${svc_dir}/conf"
  record_add "service" "${svc_dir}" "服务 mongodb"

  local bind port rootuser rootpass cache_mb cache_gb
  bind="$(prompt "绑定地址（0.0.0.0 远程可访问，127.0.0.1 仅本机）" "0.0.0.0")"
  port="$(select_port "${svc}" "MongoDB" "27017")"
  rootuser="$(prompt "Mongo root 用户名" "root")"
  rootpass="$(prompt_secret "Mongo root 密码" "<random>")"
  if [[ -z "${rootpass}" ]]; then rootpass="$(random_hex 16)"; fi

  cache_mb="$(prompt "MongoDB WiredTiger 缓存（MB）" "$(suggest_mongodb_cache_mb)")"
  if [[ ! "${cache_mb}" =~ ^[0-9]+$ ]]; then
    die "缓存必须是整数（MB）"
  fi
  cache_gb="$(awk "BEGIN { printf \"%.3f\", ${cache_mb}/1024 }")"

  write_file "${svc_dir}/.env" \
    "MONGO_INITDB_ROOT_USERNAME=${rootuser}
MONGO_INITDB_ROOT_PASSWORD=${rootpass}
TZ=Asia/Seoul
STORE_BIND=${bind}
STORE_PORT=${port}
MONGO_CACHE_GB=${cache_gb}
"

  write_file "${svc_dir}/conf/mongod.conf" \
"storage:
  dbPath: /data/db
  journal:
    enabled: true
  wiredTiger:
    engineConfig:
      cacheSizeGB: ${cache_gb}

net:
  port: 27017
  bindIp: 0.0.0.0

security:
  authorization: enabled

processManagement:
  fork: false
"

  write_file "${svc_dir}/docker-compose.yml" \
"services:
  mongo:
    image: mongo:7.0
    container_name: ${PROG_NAME}-mongodb
    restart: unless-stopped
    env_file: .env
    ports:
      - \"${bind}:${port}:27017\"
    volumes:
      - ./data:/data/db
      - ./conf/mongod.conf:/etc/mongod.conf:ro
    command: [\"mongod\", \"--config\", \"/etc/mongod.conf\"]
    healthcheck:
      test: [\"CMD-SHELL\", \"mongosh --quiet --username $(compose_escape_env MONGO_INITDB_ROOT_USERNAME) --password $(compose_escape_env MONGO_INITDB_ROOT_PASSWORD) --authenticationDatabase admin --eval 'db.runCommand({ ping: 1 }).ok' | grep 1\"]
      interval: 10s
      timeout: 10s
      retries: 12
"

  say
  say "即将部署 MongoDB："
  say "- 目录：${svc_dir}"
  say "- 绑定：${bind}:${port}"
  say "- 缓存：${cache_mb}MB (${cache_gb}GB)"
  say
  warn_if_public_bind "${bind}" "${port}" "mongodb"
  if ! confirm "现在执行 docker compose up -d？"; then
    say "已保存配置。稍后可用：${PROG_NAME} start mongodb"
    return 0
  fi

  compose "${svc}" up -d
  say "MongoDB 已启动。"
  say
  say "连接信息："
  say "- host：${bind}"
  say "- port：${port}"
  say "- user：${rootuser}"
  say "- pass：${rootpass}"
}

deploy_redis() {
  ensure_dirs
  ensure_docker || return 1
  ensure_compose || return 1

  local svc="redis"
  local svc_dir="${STORD_SERVICES_DIR}/${svc}"
  mkdir -p "${svc_dir}/data" "${svc_dir}/conf"
  record_add "service" "${svc_dir}" "服务 redis"

  local bind port pass maxmem
  bind="$(prompt "绑定地址（0.0.0.0 远程可访问，127.0.0.1 仅本机）" "0.0.0.0")"
  port="$(select_port "${svc}" "Redis" "6379")"
  maxmem="$(prompt "Redis maxmemory（如 128mb）" "$(suggest_redis_maxmem_mb)mb")"
  pass="$(prompt_secret "Redis 密码" "<random>")"
  if [[ -z "${pass}" ]]; then pass="$(random_hex 16)"; fi

  write_file "${svc_dir}/.env" \
    "TZ=Asia/Seoul
STORE_BIND=${bind}
STORE_PORT=${port}
REDIS_PASSWORD=${pass}
REDIS_MAXMEM=${maxmem}
"

  write_file "${svc_dir}/conf/redis.conf" \
"bind 0.0.0.0
port 6379
protected-mode yes
requirepass ${pass}
maxmemory ${maxmem}
maxmemory-policy allkeys-lru
appendonly yes
appendfsync everysec
save 900 1
save 300 10
save 60 10000
"

  write_file "${svc_dir}/docker-compose.yml" \
"services:
  redis:
    image: redis:7.2-alpine
    container_name: ${PROG_NAME}-redis
    restart: unless-stopped
    env_file: .env
    ports:
      - \"${bind}:${port}:6379\"
    volumes:
      - ./data:/data
      - ./conf/redis.conf:/usr/local/etc/redis/redis.conf:ro
    command: [\"redis-server\", \"/usr/local/etc/redis/redis.conf\"]
    healthcheck:
      test: [\"CMD-SHELL\", \"redis-cli -a $(compose_escape_env REDIS_PASSWORD) ping | grep PONG\"]
      interval: 10s
      timeout: 5s
      retries: 12
"

  say
  say "即将部署 Redis："
  say "- 目录：${svc_dir}"
  say "- 绑定：${bind}:${port}"
  say "- maxmemory：${maxmem}"
  say
  warn_if_public_bind "${bind}" "${port}" "redis"
  if ! confirm "现在执行 docker compose up -d？"; then
    say "已保存配置。稍后可用：${PROG_NAME} start redis"
    return 0
  fi

  compose "${svc}" up -d
  say "Redis 已启动。"
  say
  say "连接信息："
  say "- host：${bind}"
  say "- port：${port}"
  say "- pass：${pass}"
}

deploy() {
  local svc="${1:-}"
  case "${svc}" in
    mariadb) deploy_mariadb ;;
    mongodb) deploy_mongodb ;;
    redis) deploy_redis ;;
    *) die "用法：${PROG_NAME} deploy {mariadb|mongodb|redis}" ;;
  esac
}

start_service() { compose "$1" up -d; }
stop_service() { compose "$1" down; }
restart_service() { compose "$1" restart; }
status_service() { compose "$1" ps; }
logs_service() { compose "$1" logs -f --tail=200; }

for_each_deployed() {
  local svc
  while IFS= read -r svc; do
    [[ -n "${svc}" ]] || continue
    local svc_dir; svc_dir="$(service_dir "${svc}")"
    if [[ -f "${svc_dir}/docker-compose.yml" ]]; then
      printf "%s\n" "${svc}"
    else
      warn "跳过 ${svc}：缺少 docker-compose.yml"
    fi
  done < <(list_services)
}

status_all() {
  if ! compose_bin >/dev/null 2>&1; then
    say "compose 不可用，无法显示容器状态。"
    say "已部署服务目录："
    list_services | sed 's/^/ - /'
    return 0
  fi
  local any=0 svc
  while IFS= read -r svc; do
    any=1
    say
    say "== ${svc} =="
    compose "${svc}" ps || true
  done < <(for_each_deployed)
  if [[ "${any}" == "0" ]]; then
    say "暂无已部署服务。"
  fi
}

start_all() {
  local any=0 svc
  while IFS= read -r svc; do
    any=1
    say "启动：${svc}"
    compose "${svc}" up -d
  done < <(for_each_deployed)
  if [[ "${any}" == "0" ]]; then
    say "暂无已部署服务。"
  fi
}

stop_all() {
  local any=0 svc
  while IFS= read -r svc; do
    any=1
    say "停止：${svc}"
    compose "${svc}" down
  done < <(for_each_deployed)
  if [[ "${any}" == "0" ]]; then
    say "暂无已部署服务。"
  fi
}

restart_all() {
  local any=0 svc
  while IFS= read -r svc; do
    any=1
    say "重启：${svc}"
    compose "${svc}" restart
  done < <(for_each_deployed)
  if [[ "${any}" == "0" ]]; then
    say "暂无已部署服务。"
  fi
}

logs_all() {
  local any=0 svc
  while IFS= read -r svc; do
    any=1
    say
    say "== ${svc}（最近 200 行）=="
    compose "${svc}" logs --tail=200 || true
  done < <(for_each_deployed)
  if [[ "${any}" == "0" ]]; then
    say "暂无已部署服务。"
  fi
}

remove_service() {
  local svc="${1:?需要服务名}"
  say "移除服务（仅停止容器）：${svc}"
  if ! confirm "对 ${svc} 执行 docker compose down？"; then
    say "已取消。"
    return 0
  fi
  compose "${svc}" down
  say "已停止：${svc}"
}

purge_service() {
  local svc="${1:?需要服务名}"
  local svc_dir; svc_dir="$(service_dir "${svc}")"
  [[ -d "${svc_dir}" ]] || die "服务未部署：${svc}"
  say "彻底清理服务（停止 + 删除数据）：${svc}"
  say "- 目录：${svc_dir}"
  say
  warn "将删除 ${svc_dir}（包含 ./data）。"
  if ! confirm "继续清理？"; then
    say "已取消。"
    return 0
  fi
  if [[ "${STORD_ASSUME_YES}" != "1" && "${STORD_NON_INTERACTIVE}" != "1" ]]; then
    local typed
    typed="$(prompt "输入 YES 进行确认" "")"
    [[ "${typed}" == "YES" ]] || die "未确认清理"
  fi
  compose "${svc}" down || true
  rm -rf "${svc_dir}"
  say "已清理：${svc}"
}

config_path() {
  local svc="${1:?需要服务名}"
  echo "$(service_dir "${svc}")"
}

config_edit() {
  local svc="${1:?需要服务名}"
  local envf; envf="$(service_dir "${svc}")/.env"
  [[ -f "${envf}" ]] || die "缺少 env 文件：${envf}"
  local editor="${EDITOR:-}"
  if [[ -z "${editor}" ]]; then
    if have nano; then editor="nano"; elif have vim; then editor="vim"; else editor="vi"; fi
  fi
  "${editor}" "${envf}"
}

dsn_service() {
  local svc="${1:?需要服务名}"
  local host port
  host="$(dsn_host_hint "${svc}")"
  port="$(svc_host_port "${svc}")"

  case "${svc}" in
    mariadb)
      local db user pass
      db="$(env_get mariadb MARIADB_DATABASE || true)"
      user="$(env_get mariadb MARIADB_USER || true)"
      pass="$(env_get mariadb MARIADB_PASSWORD || true)"
      say "mysql://${user}:<password>@${host}:${port}/${db}"
      ;;
    mongodb)
      local user pass
      user="$(env_get mongodb MONGO_INITDB_ROOT_USERNAME || true)"
      pass="$(env_get mongodb MONGO_INITDB_ROOT_PASSWORD || true)"
      say "mongodb://${user}:<password>@${host}:${port}/?authSource=admin"
      ;;
    redis)
      say "redis://:<password>@${host}:${port}/0"
      ;;
    *)
      die "未知服务：${svc}"
      ;;
  esac
}

dsn_all() {
  local any=0 svc
  while IFS= read -r svc; do
    [[ -n "${svc}" ]] || continue
    local envf; envf="$(service_dir "${svc}")/.env"
    [[ -f "${envf}" ]] || continue
    any=1
    say "${svc}: $(dsn_service "${svc}")"
  done < <(list_services)
  if [[ "${any}" == "0" ]]; then
    say "暂无已部署服务。"
  fi
}

secrets_service() {
  local svc="${1:?需要服务名}"
  local envf; envf="$(service_dir "${svc}")/.env"
  [[ -f "${envf}" ]] || die "缺少 env 文件：${envf}"
  warn "此操作会把敏感信息打印到终端历史记录。"
  if ! confirm "显示 ${svc} 的原始密钥？"; then
    say "已取消。"
    return 0
  fi
  cat "${envf}"
}

export_config() {
  require tar
  local svc="${1:?需要服务名}"
  local svc_dir; svc_dir="$(service_dir "${svc}")"
  [[ -d "${svc_dir}" ]] || die "服务未部署：${svc}"
  local ts out
  ts="$(date -u +%Y%m%dT%H%M%SZ)"
  out="${2:-${STORD_BACKUPS_DIR}/${PROG_NAME}-${svc}-config-${ts}.tgz}"
  mkdir -p "$(dirname "${out}")"

  say "导出配置（不含数据）：${svc}"
  say "- 来源：${svc_dir}"
  say "- 目标：${out}"
  if ! confirm "继续导出？"; then
    say "已取消。"
    return 0
  fi

  local items=()
  [[ -f "${svc_dir}/docker-compose.yml" ]] && items+=("docker-compose.yml")
  [[ -f "${svc_dir}/.env" ]] && items+=(".env")
  [[ -d "${svc_dir}/conf" ]] && items+=("conf")
  [[ -d "${svc_dir}/conf.d" ]] && items+=("conf.d")
  [[ ${#items[@]} -gt 0 ]] || die "没有可导出的内容"

  (cd "${svc_dir}" && tar -czf "${out}" "${items[@]}")
  say "导出完成：${out}"
}

import_config() {
  require tar
  local svc="${1:?需要服务名}"
  local file="${2:?需要配置文件（.tgz）}"
  [[ -f "${file}" ]] || die "文件不存在：${file}"

  local svc_dir; svc_dir="$(service_dir "${svc}")"
  mkdir -p "${svc_dir}"

  warn "导入会覆盖 .env / docker-compose.yml 等文件，但不会动 ./data。"
  say "- 服务：${svc}"
  say "- 目录：${svc_dir}"
  say "- 文件：${file}"
  if ! confirm "继续导入？"; then
    say "已取消。"
    return 0
  fi

  (cd "${svc_dir}" && tar -xzf "${file}")
  say "导入完成。"
}

list_services() {
  ensure_dirs
  # Portable across GNU/BSD find (avoid -printf).
  find "${STORD_SERVICES_DIR}" -maxdepth 1 -mindepth 1 -type d 2>/dev/null \
    -exec basename {} \; | sort
}

doctor() {
  say "${PROG_NAME} doctor"
  say "- 版本：${STORD_VERSION}"
  say "- 根目录：${STORD_HOME}"
  say "- Raw URL：${STORD_RAW_URL}"
  say "- 内存：$(mem_total_mb)MB"
  say "- 建议：mariadb buffer=$(suggest_mariadb_buffer_pool_mb)MB，mongodb cache=$(suggest_mongodb_cache_mb)MB，redis maxmem=$(suggest_redis_maxmem_mb)MB"
  say
  if have docker; then
    say "docker：    ok ($(docker --version 2>/dev/null || true))"
  else
    say "docker：    缺失"
  fi
  if compose_bin >/dev/null 2>&1; then
    say "compose：   ok ($(compose_bin))"
  else
    say "compose：   缺失"
  fi
  if have curl; then
    say "curl：      ok"
  else
    say "curl：      缺失"
  fi
  if have ufw; then
    say "ufw：       ok"
  elif have firewall-cmd; then
    say "firewalld： ok"
  else
    say "防火墙：    未检测到"
  fi
  say
  say "已部署服务："
  list_services | sed 's/^/ - /'
}

firewall_allow() {
  local port="$1"
  local ip="$2"
  if have ufw; then
    ufw allow from "${ip}" to any port "${port}" proto tcp
    return 0
  fi
  if have firewall-cmd; then
    firewall-cmd --permanent --add-rich-rule="rule family=ipv4 source address=${ip} port port=${port} protocol=tcp accept"
    firewall-cmd --reload
    return 0
  fi
  die "未找到可用的防火墙工具（ufw 或 firewalld）"
}

configure_firewall_menu() {
  say
  say "防火墙助手（白名单 IP -> 端口）。"
  say "只会新增放行规则，不会删除已有规则。"
  say
  local svc ip port
  svc="$(prompt "选择服务（mariadb/mongodb/redis/custom）" "")"
  if [[ "${svc}" == "custom" ]]; then
    port="$(prompt "放行端口" "")"
    [[ "${port}" =~ ^[0-9]+$ ]] || die "端口无效：${port}"
  else
    port="$(svc_host_port "${svc}")"
  fi
  ip="$(prompt "允许的客户端 IPv4（如 1.2.3.4/32）" "")"
  [[ -n "${ip}" ]] || die "IP 不能为空"
  if ! confirm "放行 ${ip} -> ${svc} 端口 ${port}？"; then
    say "已取消。"
    return 0
  fi
  if ! is_root; then
    die "修改防火墙需要 root 权限"
  fi
  firewall_allow "${port}" "${ip}"
  say "规则已添加。"
}

backup_list_files() {
  ensure_dirs
  local svc="${1:-all}"
  local dir="${STORD_BACKUPS_DIR}"
  [[ -d "${dir}" ]] || { say "未找到备份目录：${dir}"; return 0; }

  local pat=()
  case "${svc}" in
    all) pat+=("mariadb-*.sql" "mariadb-*.sql.gz" "mongodb-*.archive" "mongodb-*.archive.gz") ;;
    mariadb) pat+=("mariadb-*.sql" "mariadb-*.sql.gz") ;;
    mongodb) pat+=("mongodb-*.archive" "mongodb-*.archive.gz") ;;
    *) die "用法：${PROG_NAME} backup files [mariadb|mongodb|all]" ;;
  esac

  say "备份文件（${dir}）："
  local out
  out="$(
    for p in "${pat[@]}"; do
      ls -1t "${dir}/${p}" 2>/dev/null || true
    done | awk 'NF' || true
  )"
  if [[ -n "${out}" ]]; then
    printf "%s\n" "${out}"
  else
    say "（无）"
  fi
}

backup_prune() {
  ensure_dirs
  local svc="${1:-all}"
  local days="${2:-}"
  if [[ -z "${days}" ]]; then
    days="$(prompt "删除多少天前的备份" "14")"
  fi
  [[ "${days}" =~ ^[0-9]+$ ]] || die "天数必须是整数"

  local dir="${STORD_BACKUPS_DIR}"
  [[ -d "${dir}" ]] || { say "未找到备份目录：${dir}"; return 0; }

  local patterns=()
  case "${svc}" in
    all) patterns+=("mariadb-*.sql" "mariadb-*.sql.gz" "mongodb-*.archive" "mongodb-*.archive.gz") ;;
    mariadb) patterns+=("mariadb-*.sql" "mariadb-*.sql.gz") ;;
    mongodb) patterns+=("mongodb-*.archive" "mongodb-*.archive.gz") ;;
    *) die "用法：${PROG_NAME} backup prune [mariadb|mongodb|all] [days]" ;;
  esac

  say "清理 ${days} 天前的备份："
  say "- 目录：${dir}"
  say "- 服务：${svc}"
  warn "该操作将删除文件。"
  if ! confirm "继续清理？"; then
    say "已取消。"
    return 0
  fi

  local pat
  for pat in "${patterns[@]}"; do
    find "${dir}" -maxdepth 1 -type f -name "${pat}" -mtime +"${days}" -print -delete 2>/dev/null || true
  done
  say "清理完成。"
}

backup_mariadb() {
  local svc_dir="${STORD_SERVICES_DIR}/mariadb"
  [[ -f "${svc_dir}/.env" ]] || die "mariadb 未部署"
  local db rootpw
  db="$(grep -E '^MARIADB_DATABASE=' "${svc_dir}/.env" | cut -d= -f2-)"
  rootpw="$(grep -E '^MARIADB_ROOT_PASSWORD=' "${svc_dir}/.env" | cut -d= -f2-)"
  [[ -n "${db}" ]] || die "缺少 MARIADB_DATABASE"
  [[ -n "${rootpw}" ]] || die "缺少 MARIADB_ROOT_PASSWORD"

  local ts out
  ts="$(date -u +%Y%m%dT%H%M%SZ)"
  if have gzip; then
    out="${STORD_BACKUPS_DIR}/mariadb-${ts}.sql.gz"
  else
    warn "未找到 gzip，将输出未压缩的 .sql"
    out="${STORD_BACKUPS_DIR}/mariadb-${ts}.sql"
  fi
  mkdir -p "${STORD_BACKUPS_DIR}"

  say "备份 MariaDB -> ${out}"
  if [[ "${out}" == *.gz ]]; then
    docker exec -i "$(container_name mariadb)" sh -c "mysqldump -uroot -p\"${rootpw}\" --single-transaction --quick \"${db}\"" \
      | gzip -9 > "${out}"
  else
    docker exec -i "$(container_name mariadb)" sh -c "mysqldump -uroot -p\"${rootpw}\" --single-transaction --quick \"${db}\"" \
      > "${out}"
  fi
  say "备份完成。"
}

backup_mongodb() {
  local svc_dir="${STORD_SERVICES_DIR}/mongodb"
  [[ -f "${svc_dir}/.env" ]] || die "mongodb 未部署"
  local user pass
  user="$(grep -E '^MONGO_INITDB_ROOT_USERNAME=' "${svc_dir}/.env" | cut -d= -f2-)"
  pass="$(grep -E '^MONGO_INITDB_ROOT_PASSWORD=' "${svc_dir}/.env" | cut -d= -f2-)"
  [[ -n "${user}" ]] || die "缺少 MONGO_INITDB_ROOT_USERNAME"
  [[ -n "${pass}" ]] || die "缺少 MONGO_INITDB_ROOT_PASSWORD"

  local ts out
  ts="$(date -u +%Y%m%dT%H%M%SZ)"
  if have gzip; then
    out="${STORD_BACKUPS_DIR}/mongodb-${ts}.archive.gz"
  else
    warn "未找到 gzip，将输出未压缩的 .archive"
    out="${STORD_BACKUPS_DIR}/mongodb-${ts}.archive"
  fi
  mkdir -p "${STORD_BACKUPS_DIR}"

  say "备份 MongoDB -> ${out}"
  if [[ "${out}" == *.gz ]]; then
    docker exec -i "$(container_name mongodb)" sh -c "mongodump --username=\"${user}\" --password=\"${pass}\" --authenticationDatabase=admin --archive" \
      | gzip -9 > "${out}"
  else
    docker exec -i "$(container_name mongodb)" sh -c "mongodump --username=\"${user}\" --password=\"${pass}\" --authenticationDatabase=admin --archive" \
      > "${out}"
  fi
  say "备份完成。"
}

backup() {
  local sub="${1:-}"
  case "${sub}" in
    mariadb) backup_mariadb ;;
    mongodb) backup_mongodb ;;
    redis) die "redis 备份：请使用卷快照（AOF/RDB 在 ./data）" ;;
    files) shift; backup_list_files "${1:-all}" ;;
    prune) shift; backup_prune "${1:-all}" "${2:-}" ;;
    enable|disable|list) backup_schedule "$@" ;;
    *) die "用法：${PROG_NAME} backup {mariadb|mongodb} | backup {files|prune} [svc] | backup {enable|disable|list} ..." ;;
  esac
}

prog_bin() {
  local p
  p="$(command -v "${PROG_NAME}" 2>/dev/null || true)"
  if [[ -n "${p}" ]]; then
    echo "${p}"
    return 0
  fi
  local self="${BASH_SOURCE[0]:-}"
  if [[ -n "${self}" && -f "${self}" ]]; then
    echo "${self}"
    return 0
  fi
  die "${PROG_NAME} 不在 PATH 中，请先安装（菜单 -> 安装/更新）"
}

cron_get() {
  ensure_crontab
  crontab -l 2>/dev/null || true
}

cron_set() {
  ensure_crontab
  local tmp
  tmp="$(mktemp)"
  trap 'rm -f "${tmp}"' RETURN
  if [[ $# -gt 0 ]]; then
    printf "%s\n" "$@" > "${tmp}"
  else
    cat > "${tmp}"
  fi
  crontab "${tmp}"
}

cron_remove_marker() {
  local marker="$1"
  cron_get | grep -v "${marker}" || true
}

backup_schedule() {
  local action="${1:-}"
  shift || true

  local marker_prefix="# ${PROG_NAME}:backup:"
  case "${action}" in
    list)
      cron_get | grep "${marker_prefix}" || true
      ;;
    enable)
      local svc="${1:?需要服务名（mariadb|mongodb）}"
      shift || true
      case "${svc}" in mariadb|mongodb) ;; *) die "不支持的服务：${svc}" ;; esac

      local hh mm
      hh="$(prompt "小时（0-23）" "3")"
      mm="$(prompt "分钟（0-59）" "30")"
      [[ "${hh}" =~ ^[0-9]+$ ]] && [[ "${mm}" =~ ^[0-9]+$ ]] || die "小时/分钟必须是整数"

      local bin; bin="$(prog_bin)"
      local marker="${marker_prefix}${svc}"
      local logf="${STORD_LOG_DIR}/backup-${svc}.log"
      local line="${mm} ${hh} * * * sh -c 'mkdir -p \"${STORD_LOG_DIR}\"; STORD_HOME=\"${STORD_HOME}\" \"${bin}\" backup ${svc} >> \"${logf}\" 2>&1' ${marker}"
      say "将添加 cron："
      say "  ${line}"
      if ! confirm "应用该 cron 任务？"; then
        say "已取消。"
        return 0
      fi
      if [[ "${STORD_NON_INTERACTIVE}" == "1" && "${STORD_ASSUME_YES}" != "1" ]]; then
        die "非交互模式拒绝修改 crontab（使用 --yes）"
      fi
      { cron_remove_marker "${marker}"; echo "${line}"; } | cron_set
      say "已启用 ${svc} 的定时备份。"
      ;;
    disable)
      local svc="${1:?需要服务名（mariadb|mongodb）}"
      local marker="${marker_prefix}${svc}"
      if ! confirm "删除 ${svc} 的 cron 定时任务？"; then
        say "已取消。"
        return 0
      fi
      if [[ "${STORD_NON_INTERACTIVE}" == "1" && "${STORD_ASSUME_YES}" != "1" ]]; then
        die "非交互模式拒绝修改 crontab（使用 --yes）"
      fi
      cron_remove_marker "${marker}" | cron_set
      say "已关闭 ${svc} 的定时备份。"
      ;;
    *)
      die "用法：${PROG_NAME} backup {enable|disable|list}"
      ;;
  esac
}

restore_mariadb() {
  local file="${1:?需要备份文件（.sql 或 .sql.gz）}"
  [[ -f "${file}" ]] || die "文件不存在：${file}"
  local db rootpw
  db="$(env_get mariadb MARIADB_DATABASE || true)"
  rootpw="$(env_get mariadb MARIADB_ROOT_PASSWORD || true)"
  [[ -n "${db}" ]] || die "缺少 mariadb 配置"
  warn "此操作会覆盖数据库中的数据：${db}"
  if ! confirm "从 ${file} 恢复 MariaDB？"; then
    say "已取消。"
    return 0
  fi
  local catcmd="cat"
  if [[ "${file}" == *.gz ]]; then
    have gzip || die "恢复 .gz 备份需要 gzip"
    catcmd="gzip -dc"
  fi
  # shellcheck disable=SC2086
  ${catcmd} "${file}" | docker exec -i "$(container_name mariadb)" sh -c "mysql -uroot -p\"${rootpw}\" \"${db}\""
  say "恢复完成。"
}

restore_mongodb() {
  local file="${1:?需要备份文件（.archive.gz 或 .archive）}"
  [[ -f "${file}" ]] || die "文件不存在：${file}"
  local user pass
  user="$(env_get mongodb MONGO_INITDB_ROOT_USERNAME || true)"
  pass="$(env_get mongodb MONGO_INITDB_ROOT_PASSWORD || true)"
  [[ -n "${user}" && -n "${pass}" ]] || die "缺少 mongodb 配置"
  warn "此操作会从备份恢复 MongoDB 数据。"
  if ! confirm "从 ${file} 恢复 MongoDB？"; then
    say "已取消。"
    return 0
  fi
  local drop_flag=""
  if confirm "恢复前先删除已有集合？"; then
    drop_flag="--drop"
  fi

  local catcmd="cat"
  if [[ "${file}" == *.gz ]]; then
    have gzip || die "恢复 .gz 备份需要 gzip"
    catcmd="gzip -dc"
  fi
  # shellcheck disable=SC2086
  ${catcmd} "${file}" | docker exec -i "$(container_name mongodb)" sh -c "mongorestore --username=\"${user}\" --password=\"${pass}\" --authenticationDatabase=admin --archive ${drop_flag}"
  say "恢复完成。"
}

restore_service() {
  local svc="${1:?需要服务名}"
  local file="${2:?需要备份文件}"
  case "${svc}" in
    mariadb) restore_mariadb "${file}" ;;
    mongodb) restore_mongodb "${file}" ;;
    *) die "用法：${PROG_NAME} restore {mariadb|mongodb} <file>" ;;
  esac
}

self_update() {
  local url="${1:-${STORD_RAW_URL}}"
  require curl
  local target
  target="$(command -v "${PROG_NAME}" || true)"
  [[ -n "${target}" ]] || die "${PROG_NAME} 不在 PATH 中"
  say "更新 ${PROG_NAME}："
  say "- 来源：${url}"
  say "- 目标：${target}"
  say
  if ! confirm "继续更新？"; then
    say "已取消。"
    return 0
  fi
  if [[ ! -w "${target}" ]]; then
    if is_root; then
      :
    else
      die "没有权限写入 ${target}"
    fi
  fi
  local tmp
  tmp="$(mktemp)"
  trap 'rm -f "${tmp}"' RETURN
  curl -fsSL "${url}" -o "${tmp}"
  chmod +x "${tmp}"
  mv -f "${tmp}" "${target}"
  say "已更新。"
}

install_self() {
  require curl
  require_root

  if [[ -n "${1:-}" ]]; then
    warn "已忽略安装目录参数，固定安装到 /usr/local/bin"
  fi

  local target_dir="/usr/local/bin"

  mkdir -p "${target_dir}"
  local target="${target_dir}/${PROG_NAME}"

  say "安装/更新 ${PROG_NAME}"
  say "- 来源：${STORD_RAW_URL}"
  say "- 目标：${target}"
  say
  if ! confirm "继续安装？"; then
    say "已取消。"
    return 0
  fi

  local tmp
  tmp="$(mktemp)"
  trap 'rm -f "${tmp}"' RETURN

  # If we are running from a real file (e.g. downloaded via wget), copy self to avoid network.
  local self="${BASH_SOURCE[0]:-}"
  if [[ -n "${self}" && -f "${self}" ]]; then
    cp -f "${self}" "${tmp}"
  else
    curl -fsSL "${STORD_RAW_URL}" -o "${tmp}"
  fi

  head -n 1 "${tmp}" | grep -q "bash" || die "下载的脚本看起来不像 bash 脚本"
  chmod +x "${tmp}"

  if [[ -e "${target}" && ! -w "${target}" ]]; then
    die "没有权限写入 ${target}"
  fi
  cp -f "${tmp}" "${target}"
  chmod +x "${target}"
  record_add "bin" "${target}" "脚本"

  say "安装完成：${target}"
}

is_dir_empty() {
  local d="$1"
  [[ -d "${d}" ]] || return 0
  [[ -z "$(ls -A "${d}" 2>/dev/null)" ]]
}

uninstall_script() {
  local bin
  bin="$(command -v "${PROG_NAME}" 2>/dev/null || true)"
  if [[ -z "${bin}" ]]; then
    bin="/usr/local/bin/${PROG_NAME}"
  fi

  say "即将卸载脚本：${bin}"
  if [[ ! -e "${bin}" ]]; then
    warn "未找到脚本文件：${bin}"
    return 0
  fi
  if ! confirm "删除该文件？"; then
    say "已取消。"
    return 0
  fi
  rm -f "${bin}"
  record_remove_path "${bin}"
  say "已删除：${bin}"
}

uninstall_all_services() {
  local any=0 svc
  say "将卸载所有服务（仅停止容器，保留数据与配置目录）。"
  if ! confirm "继续？"; then
    say "已取消。"
    return 0
  fi
  while IFS= read -r svc; do
    [[ -n "${svc}" ]] || continue
    any=1
    local svc_dir; svc_dir="$(service_dir "${svc}")"
    [[ -d "${svc_dir}" ]] || { warn "服务目录不存在：${svc_dir}"; continue; }
    remove_service "${svc}" || true
  done < <(list_services)
  if [[ "${any}" == "0" ]]; then
    say "暂无已部署服务。"
  fi
}

uninstall_single_service() {
  local svc="${1:-}"
  if [[ -z "${svc}" ]]; then
    say "已部署服务："
    list_services | sed 's/^/ - /'
    svc="$(prompt "服务名" "")"
  fi
  [[ -n "${svc}" ]] || { say "已取消。"; return 0; }
  local svc_dir; svc_dir="$(service_dir "${svc}")"
  [[ -d "${svc_dir}" ]] || { warn "服务未部署：${svc}"; return 0; }
  remove_service "${svc}"
}

uninstall_all() {
  local -a items=()
  local -a service_items=()
  local -a other_items=()
  local -a parent_items=()
  declare -A seen=()

  local type path desc line
  while IFS='|' read -r type path desc; do
    [[ -n "${type}" && -n "${path}" ]] || continue
    if [[ -z "${seen[${path}]:-}" ]]; then
      items+=("${type}|${path}|${desc}")
      seen["${path}"]=1
    fi
  done < <(record_list)

  # 补充已安装脚本路径
  local bin
  bin="$(command -v "${PROG_NAME}" 2>/dev/null || true)"
  if [[ -z "${bin}" ]]; then
    bin="/usr/local/bin/${PROG_NAME}"
  fi
  if [[ -z "${seen[${bin}]:-}" ]]; then
    items+=("bin|${bin}|脚本")
    seen["${bin}"]=1
  fi

  # 补充实际存在的服务目录（兼容旧版本未记录的情况）
  if [[ -d "${STORD_SERVICES_DIR}" ]]; then
    local svc_dir svc
    for svc_dir in "${STORD_SERVICES_DIR}"/*; do
      [[ -d "${svc_dir}" ]] || continue
      svc="$(basename "${svc_dir}")"
      if [[ -z "${seen[${svc_dir}]:-}" ]]; then
        items+=("service|${svc_dir}|服务 ${svc}")
        seen["${svc_dir}"]=1
      fi
    done
  fi

  # 补充常见目录（存在则加入）
  local d
  for d in "${STORD_BACKUPS_DIR}" "${STORD_LOG_DIR}" "${STORD_STATE_DIR}"; do
    if [[ -d "${d}" && -z "${seen[${d}]:-}" ]]; then
      items+=("dir|${d}|目录")
      seen["${d}"]=1
    fi
  done

  if [[ ${#items[@]} -eq 0 ]]; then
    say "未找到可卸载的内容。"
    return 0
  fi

  local item
  for item in "${items[@]}"; do
    IFS='|' read -r type path desc <<<"${item}"
    if [[ "${type}" == "service" ]]; then
      service_items+=("${item}")
    elif [[ "${path}" == "${STORD_HOME}" || "${path}" == "${STORD_SERVICES_DIR}" ]]; then
      parent_items+=("${item}")
    else
      other_items+=("${item}")
    fi
  done

  say "将卸载以下内容："
  for item in "${service_items[@]}" "${other_items[@]}" "${parent_items[@]}"; do
    IFS='|' read -r type path desc <<<"${item}"
    local state="存在"
    [[ -e "${path}" ]] || state="不存在"
    if [[ -n "${desc}" ]]; then
      say "- [${type}] ${path}（${desc}，${state}）"
    else
      say "- [${type}] ${path}（${state}）"
    fi
  done
  if ! confirm "继续并逐项确认删除？"; then
    say "已取消。"
    return 0
  fi

  # 先处理服务目录
  for item in "${service_items[@]}"; do
    IFS='|' read -r type path desc <<<"${item}"
    [[ -e "${path}" ]] || { say "已不存在：${path}"; continue; }
    if ! confirm "删除服务目录 ${path}？"; then
      say "已跳过：${path}"
      continue
    fi
    local svc
    svc="$(basename "${path}")"
    if [[ -f "${path}/docker-compose.yml" ]]; then
      if compose_bin >/dev/null 2>&1; then
        say "停止容器：${svc}"
        compose "${svc}" down || warn "停止容器失败：${svc}"
      else
        warn "compose 不可用，跳过停止容器：${svc}"
      fi
    fi
    rm -rf "${path}"
    record_remove_path "${path}"
    say "已删除：${path}"
  done

  # 再处理其他文件/目录
  for item in "${other_items[@]}"; do
    IFS='|' read -r type path desc <<<"${item}"
    [[ -e "${path}" ]] || { say "已不存在：${path}"; continue; }
    if ! confirm "删除 ${path}？"; then
      say "已跳过：${path}"
      continue
    fi
    if [[ -d "${path}" ]]; then
      rm -rf "${path}"
    else
      rm -f "${path}"
    fi
    record_remove_path "${path}"
    say "已删除：${path}"
  done

  # 最后处理父级空目录（仅空目录才删除）
  for item in "${parent_items[@]}"; do
    IFS='|' read -r type path desc <<<"${item}"
    [[ -d "${path}" ]] || continue
    if is_dir_empty "${path}"; then
      if confirm "删除空目录 ${path}？"; then
        rm -rf "${path}"
        record_remove_path "${path}"
        say "已删除：${path}"
      else
        say "已跳过：${path}"
      fi
    else
      warn "目录非空，保留：${path}"
    fi
  done

  say "卸载完成。"
}

menu_uninstall() {
  while true; do
    say
    say "卸载/清理："
    say "1) 仅卸载脚本"
    say "2) 卸载脚本 + 所有服务与数据"
    say "3) 仅卸载所有服务（保留数据）"
    say "4) 卸载单个服务（保留数据）"
    say "0) 返回"
    say
    local u
    u="$(menu_choice_num "选择" "1")"
    case "${u}" in
      1) uninstall_script ;;
      2) uninstall_all ;;
      3) uninstall_all_services ;;
      4) uninstall_single_service ;;
      0) return 0 ;;
      *) say "未知选项。" ;;
    esac
  done
}

is_piped_run() {
  # Heuristic: running via `curl ... | bash` means $0 is bash and there's no source file.
  [[ "${0##*/}" == "bash" || "${0##*/}" == "sh" ]] && [[ ! -f "${BASH_SOURCE[0]:-}" ]]
}

bootstrap_menu() {
  local cmd="${1:-menu}"
  if [[ "${cmd}" != "menu" && -n "${cmd}" ]]; then
    return 0
  fi
  # For the "single script" experience: allow `curl .../stord | bash`
  # to install this tool to PATH, then run the installed binary.
  if [[ "${STORD_BOOTSTRAP_DONE:-}" == "1" ]]; then
    return 0
  fi
  if ! is_piped_run; then
    return 0
  fi

  local existing
  existing="$(command -v "${PROG_NAME}" || true)"
  if [[ -n "${existing}" ]]; then
    export STORD_BOOTSTRAP_DONE=1
    exec "${existing}" menu
  fi

  install_self ""
  local installed
  installed="$(command -v "${PROG_NAME}" || true)"
  if [[ -z "${installed}" ]]; then
    # Try default locations
    if is_root && [[ -x "/usr/local/bin/${PROG_NAME}" ]]; then
      installed="/usr/local/bin/${PROG_NAME}"
    elif [[ -x "${HOME}/.local/bin/${PROG_NAME}" ]]; then
      installed="${HOME}/.local/bin/${PROG_NAME}"
    else
      die "已安装 ${PROG_NAME} 但不在 PATH 中，请把 /usr/local/bin 加入 PATH 后重试"
    fi
  fi

  export STORD_BOOTSTRAP_DONE=1
  exec "${installed}" menu
}

menu_choice_num() {
  local label="${1:-选择}"
  local def="${2:-}"
  local out
  while true; do
    if [[ -n "${def}" ]]; then
      read -r -u "${STORD_INPUT_FD}" -p "${label} [${def}]: " out || true
      out="${out:-$def}"
    else
      read -r -u "${STORD_INPUT_FD}" -p "${label}: " out || true
    fi
    [[ -n "${out}" ]] || continue
    if [[ "${out}" =~ ^[0-9]+$ ]]; then
      printf "%s" "${out}"
      return 0
    fi
    say "请输入数字。"
  done
}

menu_service_actions() {
  local svc="${1:?需要服务名（mariadb|mongodb|redis|all）}"
  while true; do
    say
    say "${PROG_NAME} — 服务：${svc}"
    say "1) 状态"
    say "2) 日志"
    say "3) 重启"
    say "4) 停止"
    say "5) 启动"
    say "6) 配置（脱敏）"
    say "7) DSN"
    say "8) 密钥（危险）"
    say "9) 立即备份"
    say "10) 恢复"
    say "11) 导出配置（tgz）"
    say "12) 导入配置（tgz）"
    say "13) 移除服务（仅停止）"
    say "14) 彻底清理（删除数据）"
    say "0) 返回"
    say

    local act
    act="$(menu_choice_num "选择" "1")"
    case "${act}" in
      1)
        if [[ "${svc}" == "all" ]]; then status_all; else status_service "${svc}"; fi
        ;;
      2)
        if [[ "${svc}" == "all" ]]; then
          logs_all
        else
          logs_service "${svc}"
        fi
        ;;
      3)
        if [[ "${svc}" == "all" ]]; then restart_all; else restart_service "${svc}"; fi
        ;;
      4)
        if [[ "${svc}" == "all" ]]; then stop_all; else stop_service "${svc}"; fi
        ;;
      5)
        if [[ "${svc}" == "all" ]]; then start_all; else start_service "${svc}"; fi
        ;;
      6)
        if [[ "${svc}" == "all" ]]; then show_env_all; else show_env "${svc}"; fi
        ;;
      7)
        if [[ "${svc}" == "all" ]]; then dsn_all; else dsn_service "${svc}"; fi
        ;;
      8)
        if [[ "${svc}" == "all" ]]; then
          warn "密钥按服务查看，请选择具体服务。"
        else
          secrets_service "${svc}"
        fi
        ;;
      9)
        case "${svc}" in
          mariadb|mongodb) backup "${svc}" ;;
          all) warn "备份是按服务执行，请选择 mariadb/mongodb。" ;;
          redis) warn "Redis 备份请使用卷快照（AOF/RDB 在 ./data）。" ;;
          *) warn "未知服务：${svc}" ;;
        esac
        ;;
      10)
        case "${svc}" in
          mariadb|mongodb)
            local f
            f="$(prompt "备份文件路径" "")"
            restore_service "${svc}" "${f}"
            ;;
          *) warn "仅支持恢复 mariadb/mongodb。" ;;
        esac
        ;;
      11)
        if [[ "${svc}" == "all" ]]; then
          warn "导出配置需指定服务。"
        else
          local o
          o="$(prompt "输出文件（可选）" "")"
          if [[ -n "${o}" ]]; then export_config "${svc}" "${o}"; else export_config "${svc}"; fi
        fi
        ;;
      12)
        if [[ "${svc}" == "all" ]]; then
          warn "导入配置需指定服务。"
        else
          local cf
          cf="$(prompt "配置 tgz 路径" "")"
          import_config "${svc}" "${cf}"
        fi
        ;;
      13)
        if [[ "${svc}" == "all" ]]; then
          warn "移除需指定服务。"
        else
          remove_service "${svc}"
        fi
        ;;
      14)
        if [[ "${svc}" == "all" ]]; then
          warn "清理需指定服务。"
        else
          purge_service "${svc}"
        fi
        ;;
      0) return 0 ;;
      *) say "未知选项。" ;;
    esac
  done
}

menu_select_service() {
  while true; do
    say
    say "选择服务："
    say "1) MariaDB"
    say "2) MongoDB"
    say "3) Redis"
    say "4) 全部"
    say "5) 列出已部署"
    say "0) 返回"
    say
    local s
    s="$(menu_choice_num "选择" "1")"
    case "${s}" in
      1) echo "mariadb"; return 0 ;;
      2) echo "mongodb"; return 0 ;;
      3) echo "redis"; return 0 ;;
      4) echo "all"; return 0 ;;
      5)
        say "已部署："
        list_services | sed 's/^/ - /'
        ;;
      0) echo ""; return 0 ;;
      *) say "未知选项。" ;;
    esac
  done
}

menu_deploy() {
  while true; do
    say
    say "部署："
    say "1) MariaDB"
    say "2) MongoDB"
    say "3) Redis"
    say "0) 返回"
    say
    local d
    d="$(menu_choice_num "选择" "1")"
    case "${d}" in
      1) deploy mariadb || true ;;
      2) deploy mongodb || true ;;
      3) deploy redis || true ;;
      0) return 0 ;;
      *) say "未知选项。" ;;
    esac
  done
}

menu_backups() {
  while true; do
    say
    say "备份："
    say "1) 列出备份文件"
    say "2) 清理旧备份"
    say "3) 定时备份（启用/禁用/列表）"
    say "0) 返回"
    say
    local b
    b="$(menu_choice_num "选择" "1")"
    case "${b}" in
      1)
        local s
        s="$(prompt "服务（mariadb/mongodb/all）" "all")"
        backup files "${s}"
        ;;
      2)
        local s d
        s="$(prompt "服务（mariadb/mongodb/all）" "all")"
        d="$(prompt "保留最近 N 天" "14")"
        backup prune "${s}" "${d}"
        ;;
      3)
        local a s
        a="$(prompt "动作（enable/disable/list）" "list")"
        if [[ "${a}" == "list" ]]; then
          backup list
        else
          s="$(prompt "服务（mariadb/mongodb）" "")"
          backup "${a}" "${s}"
        fi
        ;;
      0) return 0 ;;
      *) say "未知选项。" ;;
    esac
  done
}

menu() {
  ensure_dirs
  maybe_offer_update

  while true; do
    say
    say "${PROG_NAME} ${STORD_VERSION} — ${STORD_HOME}"
    say "1) 管理服务（状态/日志/重启/备份等）"
    say "2) 部署服务"
    say "3) 备份"
    say "4) 防火墙白名单助手"
    say "5) Doctor（环境自检）"
    say "6) 安装/更新 ${PROG_NAME}"
    say "7) 自更新 ${PROG_NAME}（下载 raw）"
    say "8) 检查更新"
    say "9) 卸载/清理"
    say "0) 退出"
    say

    local top
    top="$(menu_choice_num "选择" "1")"
    case "${top}" in
      1)
        local svc
        svc="$(menu_select_service)"
        [[ -n "${svc}" ]] || continue
        menu_service_actions "${svc}"
        ;;
      2) menu_deploy ;;
      3) menu_backups ;;
      4) configure_firewall_menu ;;
      5) doctor ;;
      6) install_self "" ;;
      7) self_update ;;
      8) check_update || true ;;
      9) menu_uninstall ;;
      0) exit 0 ;;
      *) say "未知选项。" ;;
    esac
  done
}

usage() {
  cat <<EOF
${PROG_NAME} - 单机存储部署工具

用法：
  ${PROG_NAME}                # 交互菜单（如用 curl|bash 会自动安装）
  ${PROG_NAME} [--yes] [--non-interactive] <command> ...
  ${PROG_NAME} menu
  ${PROG_NAME} doctor
  ${PROG_NAME} check-update
  ${PROG_NAME} install        # 安装到 /usr/local/bin
  ${PROG_NAME} deploy <svc>   # mariadb|mongodb|redis
  ${PROG_NAME} start <svc|all>
  ${PROG_NAME} stop <svc|all>
  ${PROG_NAME} restart <svc|all>
  ${PROG_NAME} status [svc|all]       # 默认：all
  ${PROG_NAME} logs <svc|all>
  ${PROG_NAME} config [svc|all]       # 查看脱敏 env（默认：all）
  ${PROG_NAME} secrets <svc>          # 打印原始 env（危险）
  ${PROG_NAME} dsn [svc|all]          # 输出连接串模板（默认：all）
  ${PROG_NAME} backup mariadb|mongodb
  ${PROG_NAME} backup files [svc]     # 列出本地备份
  ${PROG_NAME} backup prune [svc] [days]
  ${PROG_NAME} backup enable <svc>    # crontab 定时备份
  ${PROG_NAME} backup disable <svc>
  ${PROG_NAME} backup list
  ${PROG_NAME} restore <svc> <file>   # mariadb|mongodb
  ${PROG_NAME} remove <svc>           # 停止容器
  ${PROG_NAME} purge <svc>            # 停止 + 删除数据目录
  ${PROG_NAME} export-config <svc> [out.tgz]
  ${PROG_NAME} import-config <svc> <file.tgz>
  ${PROG_NAME} config-path <svc>
  ${PROG_NAME} config-edit <svc>
  ${PROG_NAME} firewall              # 防火墙白名单（root）
  ${PROG_NAME} uninstall [script|all|services|<svc>]
  ${PROG_NAME} self-update [url]
  ${PROG_NAME} --version
EOF
}

main() {
  local cmd="${1:-menu}"
  case "${cmd}" in
    -v|--version) say "${STORD_VERSION}"; exit 0 ;;
    menu) shift || true; menu "$@" ;;
    doctor) shift; doctor "$@" ;;
    check-update) shift; check_update ;;
    install) shift; install_self "${1:-}" ;;
    deploy) shift; deploy "$@" ;;
    start)
      shift
      if [[ "${1:-}" == "all" || -z "${1:-}" ]]; then start_all; else start_service "${1}"; fi
      ;;
    stop)
      shift
      if [[ "${1:-}" == "all" || -z "${1:-}" ]]; then stop_all; else stop_service "${1}"; fi
      ;;
    restart)
      shift
      if [[ "${1:-}" == "all" || -z "${1:-}" ]]; then restart_all; else restart_service "${1}"; fi
      ;;
    status)
      shift
      if [[ "${1:-}" == "all" || -z "${1:-}" ]]; then status_all; else status_service "${1}"; fi
      ;;
    logs)
      shift
      if [[ "${1:-}" == "all" ]]; then logs_all; else logs_service "${1:?需要服务名}"; fi
      ;;
    config)
      shift
      if [[ "${1:-}" == "all" || -z "${1:-}" ]]; then show_env_all; else show_env "${1}"; fi
      ;;
    secrets) shift; secrets_service "${1:?需要服务名}" ;;
    dsn)
      shift
      if [[ "${1:-}" == "all" || -z "${1:-}" ]]; then dsn_all; else dsn_service "${1}"; fi
      ;;
    backup) shift; backup "$@" ;;
    restore) shift; restore_service "${1:?需要服务名}" "${2:?需要备份文件}" ;;
    remove) shift; remove_service "${1:?需要服务名}" ;;
    purge) shift; purge_service "${1:?需要服务名}" ;;
    export-config) shift; export_config "${1:?需要服务名}" "${2:-}" ;;
    import-config) shift; import_config "${1:?需要服务名}" "${2:?需要配置文件}" ;;
    config-path) shift; config_path "${1:?需要服务名}" ;;
    config-edit) shift; config_edit "${1:?需要服务名}" ;;
    firewall) shift; configure_firewall_menu ;;
    self-update) shift; self_update "$@" ;;
    uninstall)
      shift || true
      case "${1:-}" in
        script) uninstall_script ;;
        all) uninstall_all ;;
        services) uninstall_all_services ;;
        "" ) menu_uninstall ;;
        *) uninstall_single_service "${1}" ;;
      esac
      ;;
    help|-h|--help) usage ;;
    *)
      # Default to menu for unknown (friendlier).
      usage
      exit 1
      ;;
  esac
}

entry() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -y|--yes)
        STORD_ASSUME_YES=1
        shift
        ;;
      --non-interactive)
        STORD_NON_INTERACTIVE=1
        shift
        ;;
      --debug)
        STORD_DEBUG=1
        set -x
        shift
        ;;
      --quiet)
        STORD_QUIET=1
        shift
        ;;
      --)
        shift
        break
        ;;
      -*)
        break
        ;;
      *)
        break
        ;;
    esac
  done
  require_root
  bootstrap_menu "${1:-menu}"
  main "$@"
}

entry "$@"
